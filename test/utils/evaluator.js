let { spawn } = require('child_process');
let wait = require('./wait');

// Stores logs generated by the test cases 
let logbuffer = [];

/**
 * Returns a list of logs.
 * Waits until the number of requested logs have accumulated.
 * There's a timeout to force it to stop checking.
 * 
 * @param {Number} count 
 * @param {Number} timeout 
 * @returns {Promise<String[]>}
 */
async function logs (count = 1, timeout = 5000) {
    let start = Date.now();

    // Wait until we acquire the requested number of logs
    while (logbuffer.length < count) {
        await wait(100);

        if (Date.now() - start > timeout) {
            break;
        }
    }

    // return the logs and clear it afterwards
    return logbuffer.splice(0, logbuffer.length);
}

/**
 * Call the global function in the VM.
 * 
 * @param {String} fn 
 * @param {*} arg 
 */
async function call (fn, arg) {
    // TODO: Find deterministic way of handling this
    await wait(100);
    global._evaluatorInstance.send({ call: [fn, arg] });
    await wait(100);
}

/**
 * Sends updated bundle chunks to VM.
 * 
 * @param {Object[]} chunks 
 */
function invalidate (chunks) {
    global._evaluatorInstance.send({ invalidate: true, chunks });
}

/**
 * Evaluates the VM with the provided code.
 * 
 * @param {String} format 
 * @param {String} entry 
 * @param {Object[]} chunks 
 * @param {Object} globals 
 * @param {Boolean} async 
 * @returns {Object}
 */
function init (format, entry, chunks, globals = {}, async = false) {
    logbuffer = [];

    return new Promise((resolve, reject) => {
        let impl = (resolve, reject) => {
            global._evaluatorResultListener = msg => {
                if (msg.log) {
                    logbuffer.push(msg.log);
                    return;
                }

                if (msg.error) {
                    return reject(msg.error);
                }

                resolve({ globals: msg.globals, exports: msg.result });
            };

            global._evaluatorInstance.send({ format, entry, chunks, globals, async });
        };

        // The forked node may not be ready yet when the test starts.
        // This will push the test into a backlog.
        if (!global._evaluatorReady) {
            global._evaluatorReadyListeners.push(() => impl(resolve, reject));
        } else {
            impl(resolve, reject);
        }
    });
}

before(() => {
    // Create instance of NodeJS with ESM mode enabled.
    // We will use this one instance for all tests.
    // When it is ready, it will notify us and we can proceed with testing.
    if (!global._evaluatorInstance) {
        global._evaluatorReady = false;
        global._evaluatorReadyListeners = [];
        global._evaluatorResultListener = undefined;

        let forked = spawn('node', [
            '--experimental-vm-modules', 
            process.cwd() + '/test/utils/evaluator-worker.js' 
        ], {
            stdio: [null, null, null, 'ipc']
        });

        forked.stdout.on('data', d => console.log(d.toString()));
        forked.stderr.on('data', d => console.error(d.toString()));

        forked.on('message', msg => {
            if (msg.ready) {
                global._evaluatorReady = true;
                global._evaluatorReadyListeners.forEach(listener => listener());
                global._evaluatorReadyListeners = [];
            } else {
                global._evaluatorResultListener(msg);
            }
        });

        global._evaluatorInstance = forked;
    }

});

after(() => {
    if (global._evaluatorInstance) {
        global._evaluatorInstance.kill();
    }

    global._evaluatorInstance = undefined;
});

module.exports = { init, invalidate, logs, call };
